#pragma once
#include "definecell.hpp"

// Reads the map provided in .txt format
vector<vector<int>> Astarplanner::read_map(string &path){

    vector<vector<int>> grid1;  
    ifstream infile; 
    infile.open(path);
    string line;
    
  while (infile)
  {
    string s;
    int number = 0; 
    if (!getline( infile, s )) break;

    istringstream ss( s );
    vector <int> record;

    while (ss)
    {
      string s;
      if (!getline( ss, s, ',' )) break;
      number = stoi(s); 
      record.push_back( number );
    }
    grid1.push_back(record);
  }
  if (!infile.eof())
  {
    cerr << "Error\n";
  }
  return grid1; 
}


// Returns and print the path, if found by the algorithm.
void Astarplanner::pathfound(const vector<vector<Position_Cell>> & TrackerCell, const vector<int>& dest,const vector<int>& src )
{   
	cout<<"The Path generated by the A* algorithm is: ";
	stack<values> Path;
	int row = dest[0];
	int col = dest[1];
	values next_node = TrackerCell[row][col].Parent;
	do {
		Path.push(next_node);
		next_node = TrackerCell[row][col].Parent;
		row = next_node.x;
		col = next_node.y;
		
	} while (TrackerCell[row][col].Parent.x != next_node.x ||
	TrackerCell[row][col].Parent.y != next_node.y );
        
	Path.emplace(row, col);
	values q(-1,-1);
	
	while (!Path.empty() &&  q.x != Path.top().x || q.y != Path.top().y) {
		values p = Path.top();
		cout<<"("<<p.x<<","<<p.y<<") ";
		Path.pop();
		q = p;
		
	}
	cout<<"("<<dest[0]<<","<<dest[1]<<"). \n";
}



// Prints the grid to show its elements
void printgrid (vector<vector<int>> &grid) {
    cout << grid.size() << " " << grid[0].size() << "\n"; 
    for (int i = 0; i < grid.size(); i++){
        for (int j = 0; j < grid[1].size(); j++){
            cout <<grid[i][j] << " ";  
        }
        cout << "" << "\n"; 
    }
}


